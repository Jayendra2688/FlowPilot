âš›ï¸ React Learnings

async function vs const handleClick = async () => {}

Both work fine inside components.

The only difference is scope â€” arrow functions inherit the componentâ€™s scope, while normal functions donâ€™t if declared outside.

export default importance

You must export default your React component if youâ€™re importing it elsewhere.

If it â€œworks without exportâ€, itâ€™s probably a cached dev-server quirk, not real ES module behavior.

useParams() + Dynamic Routes

Lets you grab URL parts like /steps/:id â†’ const { id } = useParams();

That id can be passed in fetch requests.

How useEffect actually behaves

It runs twice in dev mode because of React Strict Mode (dev-only).

In production, itâ€™ll run once.

You can guard or ignore it.

Rendering API Data

You canâ€™t render raw objects (<p>{data}</p>) â€” React only accepts strings/numbers.

Use JSON.stringify(data, null, 2) to debug, or map over arrays like:

data.map(item => <li key={item.id}>{item.name}</li>)

ğŸ Django + API Learnings

Query param vs path param

You used path('steps/', ...) â†’ this means you must call /api/steps/?id=xyz.

/api/steps/id=xyz wonâ€™t match â†’ causes 404.

Returning Django objects

You canâ€™t return Response(workflow.steps.all().first()) because Django models arenâ€™t JSON serializable.

Always serialize them (manually or via a DRF Serializer).

Proper DRF Response example

steps = workflow.steps.all()
data = [{"id": s.id, "name": s.name} for s in steps]
return Response(data)

ğŸ§© Full Flow Understanding

You now understand how to:

Pass an ID from one page (/workflows/:id) to another (/steps/:id) using React Router.

Use useParams to extract that ID.

Fetch backend data based on it.

Make your Django view return clean JSON.

Render that JSON properly in React.