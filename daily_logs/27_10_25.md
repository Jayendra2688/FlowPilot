⚛️ React Learnings

async function vs const handleClick = async () => {}

Both work fine inside components.

The only difference is scope — arrow functions inherit the component’s scope, while normal functions don’t if declared outside.

export default importance

You must export default your React component if you’re importing it elsewhere.

If it “works without export”, it’s probably a cached dev-server quirk, not real ES module behavior.

useParams() + Dynamic Routes

Lets you grab URL parts like /steps/:id → const { id } = useParams();

That id can be passed in fetch requests.

How useEffect actually behaves

It runs twice in dev mode because of React Strict Mode (dev-only).

In production, it’ll run once.

You can guard or ignore it.

Rendering API Data

You can’t render raw objects (<p>{data}</p>) — React only accepts strings/numbers.

Use JSON.stringify(data, null, 2) to debug, or map over arrays like:

data.map(item => <li key={item.id}>{item.name}</li>)

🐍 Django + API Learnings

Query param vs path param

You used path('steps/', ...) → this means you must call /api/steps/?id=xyz.

/api/steps/id=xyz won’t match → causes 404.

Returning Django objects

You can’t return Response(workflow.steps.all().first()) because Django models aren’t JSON serializable.

Always serialize them (manually or via a DRF Serializer).

Proper DRF Response example

steps = workflow.steps.all()
data = [{"id": s.id, "name": s.name} for s in steps]
return Response(data)

🧩 Full Flow Understanding

You now understand how to:

Pass an ID from one page (/workflows/:id) to another (/steps/:id) using React Router.

Use useParams to extract that ID.

Fetch backend data based on it.

Make your Django view return clean JSON.

Render that JSON properly in React.