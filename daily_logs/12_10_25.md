ğŸ§  FlowPilot - Architecture & Design Notes (12 Oct 2025)
1. Solution Architecture

Purpose: Build a resilient workflow execution system that separates definition from execution.

Core Models

WorkflowExecution â€“ tracks each workflow run.

TaskExecution â€“ tracks each stepâ€™s state.

Celery + Redis â€“ handle async execution and retries.

State Machine â€“ ensures valid transitions and failure recovery.

Key Idea:

Define what should happen once; execute when and how it happens many times.

2. Distributed System Rationale

To scale and isolate concerns: Django handles API requests, Celery handles heavy work.

Architecture

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Django API    â”‚    â”‚ Celery Worker â”‚    â”‚ Celery Worker â”‚
â”‚ (Triggers)    â”‚    â”‚ (Executes)    â”‚    â”‚ (Executes)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ Redis MQ   â”‚
               â”‚ (Broker)   â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Example

# Monolithic (slow)
def create_patient():
    send_otp()
    send_email()

# Distributed (fast)
def create_patient():
    execute_workflow.delay()


Why Itâ€™s Distributed

Separate processes (web & workers)

Communicate via network (Redis)

Fault tolerance â€” one crash doesnâ€™t stop all

Patterns

Producerâ€“Consumer

Message Passing (.delay() â†’ Celery)

Shared State (DB + Redis)

3. Workflowâ€“Step Relationship

Workflows persist independently for audit.

Steps are dependent â€” deleting workflow removes steps.

4. Model Design

Self-Referencing Dependencies

depends_on = models.ManyToManyField(
    'self',
    blank=True,
    symmetrical=False,
    related_name='dependents'
)


Ordering

ordering = ['step_order']


Retries

parent_execution = models.ForeignKey(
    'self',
    null=True, blank=True,
    on_delete=models.SET_NULL,
    related_name='retries'
)


Optimized Updates

self.save(update_fields=['status', 'completed_at'])

5. ORM Optimization

Avoid N+1 queries.

Bad

for e in WorkflowExecution.objects.all():
    retry_count = e.retries.count()


Better

WorkflowExecution.objects.select_related('created_by').prefetch_related('retries')

6. TaskExecution Additions
worker_id = models.CharField(max_length=255, blank=True)
celery_task_id = models.CharField(max_length=255, blank=True)


Execution Readiness

def is_ready_for_execution(self):
    if self.status != 'pending':
        return False
    completed = set(
        self.workflow_execution.task_executions
        .filter(status='completed')
        .values_list('step_id', flat=True)
    )
    return self.step.can_execute(completed)

7. Dependencies
psycopg2-binary==2.9.9
python-dotenv==1.0.0