🧠 FlowPilot - Architecture & Design Notes (12 Oct 2025)
1. Solution Architecture

Purpose: Build a resilient workflow execution system that separates definition from execution.

Core Models

WorkflowExecution – tracks each workflow run.

TaskExecution – tracks each step’s state.

Celery + Redis – handle async execution and retries.

State Machine – ensures valid transitions and failure recovery.

Key Idea:

Define what should happen once; execute when and how it happens many times.

2. Distributed System Rationale

To scale and isolate concerns: Django handles API requests, Celery handles heavy work.

Architecture

┌───────────────┐    ┌───────────────┐    ┌───────────────┐
│ Django API    │    │ Celery Worker │    │ Celery Worker │
│ (Triggers)    │    │ (Executes)    │    │ (Executes)    │
└───────────────┘    └───────────────┘    └───────────────┘
         │                     │
         └────────────┬────────┘
                      │
               ┌────────────┐
               │ Redis MQ   │
               │ (Broker)   │
               └────────────┘


Example

# Monolithic (slow)
def create_patient():
    send_otp()
    send_email()

# Distributed (fast)
def create_patient():
    execute_workflow.delay()


Why It’s Distributed

Separate processes (web & workers)

Communicate via network (Redis)

Fault tolerance — one crash doesn’t stop all

Patterns

Producer–Consumer

Message Passing (.delay() → Celery)

Shared State (DB + Redis)

3. Workflow–Step Relationship

Workflows persist independently for audit.

Steps are dependent — deleting workflow removes steps.

4. Model Design

Self-Referencing Dependencies

depends_on = models.ManyToManyField(
    'self',
    blank=True,
    symmetrical=False,
    related_name='dependents'
)


Ordering

ordering = ['step_order']


Retries

parent_execution = models.ForeignKey(
    'self',
    null=True, blank=True,
    on_delete=models.SET_NULL,
    related_name='retries'
)


Optimized Updates

self.save(update_fields=['status', 'completed_at'])

5. ORM Optimization

Avoid N+1 queries.

Bad

for e in WorkflowExecution.objects.all():
    retry_count = e.retries.count()


Better

WorkflowExecution.objects.select_related('created_by').prefetch_related('retries')

6. TaskExecution Additions
worker_id = models.CharField(max_length=255, blank=True)
celery_task_id = models.CharField(max_length=255, blank=True)


Execution Readiness

def is_ready_for_execution(self):
    if self.status != 'pending':
        return False
    completed = set(
        self.workflow_execution.task_executions
        .filter(status='completed')
        .values_list('step_id', flat=True)
    )
    return self.step.can_execute(completed)

7. Dependencies
psycopg2-binary==2.9.9
python-dotenv==1.0.0